:namespace API
    nl←⎕UCS 13
    ⎕ml←1
    ⎕io←1
    Timeout←180 ⍝ seconds before we consider a job to have timedout
    DEBUG←1
    If←/⍨   ⍝  AB's father

    ∇ (R log)←APLVersions args;k;i;keys;int;exe;bak;cnt;file;json;old;doc;platform;fld;cJSON;z1;z2;t;old∆;k2;lglv
⍝:: Reports the current list of local interpreters (or updates it with the right modifieres set)
⍝?: Reports the current list of local interpreters (or updates it with the right modifieres set)
⍝?:
⍝?: ]APLVersions   [-update] [-enable[=id[,id]] [-disable[=id[,id]]
⍝??: Without modifiers, prints a list of local interpreters (according to interpreters.json5)
⍝??: -update              rebuild list
⍝??: -enable              enable all interpreters
⍝??: -enable=ids          enable list of interpreters given in ids
⍝??: -disable             disable all interpreters
⍝??: -disable=ids         disable list of interpreters given in ids
⍝??:
⍝?? interpreters.json is located in different folders, depending on the OS. Running the command will show the location of the file.
⍝ParseU: 0 -update -enable[∊]0123456789UC, -disable[∊]0123456789UC,
⍝ParseA: 0 -update -ucmd=0 -loglevel∊0123 -compact
⍝ This describes the syntax for calls through the API-Interface.
⍝ loglevel provides a possibility to select the desired level of detail for the messages in the log.
⍝ the level of detail increases as numbers increase in value:
⍝ 0 - no logging at all
⍝ 1 - simple msg about the name of the file that was created or updated
⍝ 2 - report new or disabled interpreters
⍝ 3 - everything
⍝
⍝ Additionally, the API-Call can use the option "-compact" to generate two-row report of enabled & disabled APL-Interpreters
     
      args←##._Parse args  ⍝ ensure its a parsed arg...
      int←⍬
      cJSON←⎕JSON⍠'Compact' 0
      log←''
      :If ⎕NEXISTS file←_FileWithListOfInterpreters
          log←⊂'Using list of interpreters from file "',file,'"'
          old∆←⎕JSON ⎕JSON old←(⎕JSON⍠'Dialect' 'JSON5')1⊃⎕NGET file
          :If 0≡args.Switch'update'
              Disable←{⍝ ⍺=interpreters,  ⍵[1] ids to handle, ⍵[2]=new value
                  i←⍸⍺.id∊int←','(≠⊆⊢)1⊃⍵
                  ⍺[i].disabled←⍵[2]
                  z←~int∊⍺.id
                  1=∨/z:⎕←'Version(s) ',(¯2↓∊'"',¨int,¨⊂'", '),' not found!'
              }
              :If 0≢t←args.Switch'disable'
                  :If t≡1 ⋄ t←¯1↓∊old.id,¨',' ⋄ :EndIf
                  old Disable t(∊'"Disabled with ""]APLVersions -disable"" on "Dddd, DDoo Mmmm YYYY; hh:mm:ss'(1200⌶)1 ⎕DT⊂⎕TS)
              :EndIf
              :If 0≢t←args.Switch'enable'
                  :If t≡1 ⋄ t←¯1↓∊old.id,¨',' ⋄ :EndIf
                  old Disable t''
              :EndIf
              k←↑7↑¨({6::0 ⋄ 'doc'≢⍵.id:0=≢⍵.disabled ⋄ 0}¨old)/old.id
              k2←↑7↑¨({6::1 ⋄ 'doc'≢⍵.id:0<≢⍵.disabled ⋄ 0}¨old)/old.id
              :If 1≡args.Switch'compact'
                  log,←⊂'enabled : ',¯2↓,(k,','),' '
                  log,←⊂'disabled: ',¯2↓,(k2,','),' '
              :Else
                  log,←⊂'enabled   disabled'
                  log,←⊂'-------   --------'
                  log,←↓k{a←⍺,' ' ⋄ a,⍥{(a⌈⍥≢w)↑⍵}⍵}w←' ',' ',k2
              :EndIf
              R←⍬
              :If old≢old∆
                  (⊂cJSON old)⎕NPUT file 1
                  ⍝     log,←⊂'Updated file "',file,'"'
              :EndIf
              →End
          :EndIf
      :ElseIf 1≢args.Switch'update'
          log←⊂'No list of interpreters found. File ',file,' does not exist.'
          →End
      :EndIf
     
      lglv←2 args.Switch'loglevel'
     
      :Select platform
     
      :Case 'Win'
          keys←##.WinReg.GetAllSubKeyNames dyalog←'HKEY_CURRENT_USER\SOFTWARE\Dyalog'
          :For k :In keys
              :If (12↑k)≡'Dyalog APL/W'  ⍝ is it an interpreter
                  exe←(##.WinReg.GetString dyalog,'\',k,'\Dyalog'){⍺,((~∨/'\/'=¯1↑⍺)/'\'),⍵}'dyalog.exe'
                  :If ⎕NEXISTS exe
                      i←⎕NS'' ⍝ collect data in this ns
                      i.exe←∊1 ⎕NPARTS exe
                      i.Bits←(32 64)[1+'-64'≡3↑12↓k]
                      i.Edition←'CU'[1+∨/'Unicode'⍷k]
                      i.Version←3⊃2⊃' '⎕VFI k
                      i.id←i.((⍕Version×10),Edition,⍕Bits)
                      int,←i
                  :ElseIf lglv>1
                      log,←⊂'Registry key "',k,'" was not considered because "',exe,'" was not found!'
                  :EndIf
              :EndIf
          :EndFor
      :Case 'Mac'
          :For fld :In '/Applications/Dyalog*' '/Dyalog/Dyalog*'
              :For k :In ⊃0(⎕NINFO⍠1)
                  exe←k,'/Contents/Resources/Dyalog/mapl'
                  :If ⎕NEXISTS exe
                      i←⎕NS'' ⍝ collect data in this ns
                      i.exe←∊1 ⎕NPARTS exe
                      i.Bits←64
                      i.Edition←'U'
                      i.Version←2⊃2⊃'-'⎕VFI ¯4↓k
                      i.id←i.((⍕Version×10),Edition,⍕Bits)
                      int,←i
                  :ElseIf lglv>1
                      log,←⊂'Folder "',k,'" was excluded because it did not contain expected "',exe,'"'
                  :EndIf
              :EndFor
          :EndFor
      :Case 'Lin'
          :For exe :In ⊃0(⎕NINFO⍠'Recurse' 1)'/opt/mdyalog/mapl'
              :If ⎕NEXISTS exe
                  i←⎕NS'' ⍝ collect data in this ns
                  i.exe←∊1 ⎕NPARTS exe
                  i.Bits←64
                  i.Edition←'CU'[1+∨/'unicode'⍷exe]
                  i.Version←4⊃2⊃'/'⎕VFI exe
                  i.id←i.((⍕Version×10),Edition,⍕Bits)
                  int,←i
              :ElseIf lglv>1
                  log,←⊂'Folder "',k,'" was excluded because it did not contain expected "',exe,'"'
              :EndIf
          :EndFor
     
      :EndSelect
     
     
     
      :If 0<≢int
          doc←⎕NS''
          doc.id←'doc'
          doc._←⊂'This file is created, used and updated by CITA (Continous Integration & Testing in APL)         '
          doc._,←⊂'------------------------------------------------------------------------------------------------'
          doc._,←⊂'It contains the complete inventory of locally installed interpreters that might be used in tests'
          doc._,←⊂'when ExecuteLocalTests is called with the ''a''-Flag.                                             '
          doc._,←⊂'It is possible to indicate non-availability for tests of individual interpreters by setting     '
          doc._,←⊂'''disabled'' to a non-empty string.                                                               '
          doc._,←⊂'The ''id''-field is used to identify interpreters, while ''Bits'' and ''Edition'' describe the        '
          doc._,←⊂'respective characteristics of an interpreter.                                                   '
          doc._,←⊂'If any interpreter in this list should not be found again on a re-scan, its entry will get      '
          doc._,←⊂'a value in the ''disabled''-field, we never delete from this list! Newly installed interpreters   '
          doc._,←⊂'will be added (and will be enabled) automatically.                                              '
          doc.disabled←'Doc is read, not executed!'
     
          int←doc,int
     
          :If ⎕NEXISTS file
              :If old.id≡(⊂'doc'),int.id
              :AndIf old≡⍥{6::'' ⋄ ⍵.disabled}int  ⍝ also compare "disabled" - but avoid VALUE ERRORs
              :AndIf old≡⍥{6::'' ⋄ ⍵.exe}int
                  R←1
                  :If lglv>0 ⋄ log←⊂'No changes found - file "',file,'" was not replaced' ⋄ :EndIf
                  →End
              :Else
                  z1←({6::1 ⋄ 0=≢⍵.disabled}¨old)∧~old.id∊int.id
                  :If ∨/z1
                      (z1/old)⍎¨⊂'disabled←∊''"Disabled by interpreter-scan on "Dddd, DDoo Mmmm YYYY; hh:mm:ss''(1200⌶)1 ⎕DT ⊂⎕TS'
                      :If lglv>1
                          log,←⊂'Disabled ',(¯2↓∊'"',¨z1/old.id,¨⊂'", '),' which were not found'
                      :EndIf
                  :EndIf
                  z2←~int.id∊old.id
                  old←old,z2/int
                  :If ∨/z2
                      (z2/int)⍎¨⊂'Added←∊''"Added on "Dddd, DDoo Mmmm YYYY; hh:mm:ss''(1200⌶)1 ⎕DT ⊂⎕TS'
                      :If lglv>1
                          log,←⊂'Found and included new interpreters: ',¯2↓∊'"',¨z2/int.id,¨⊂'", '
                      :EndIf
                  :EndIf
                  :If 1∊z1,z2
                      old←old[⍋old.id]
                      old←old[(≢old){⍵,(⍳⍺)~⍵}old.id⍳⊂'doc']  ⍝ make sure doc stays on top
                      (⊂cJSON old)⎕NPUT file 1
                      :If lglv>0
                          log,←⊂'Updated "',file,'"'
                      :EndIf
                  :Else
                      log←'No changes found, "',file,'" is still current.'
                  :EndIf
              :EndIf
          :Else
              :If lglv>0
                  log,←⊂'Created "',file,'"'
              :EndIf
              (⊂cJSON int)⎕NPUT file
          :EndIf
          R←1
      :Else
          R←0
          log,←⊂'Nothing to do - no interpreters found! (How did you even execute this code?)'
      :EndIf
     End:
      :If 1≡args.Switch'ucmd'
          R←⍬  ⍝ no need to show interpretation of rc when running UCMD
      :EndIf
    ∇

    ∇ {(res Log)}←ExecuteLocalTest arg;fld;fl;loc;xin;rc;specs;R;step;specsObj;lg;cnt;list;showedIO;log;del;list2;v;xin∆;jlog;cfg;rcTest;interpreters;interpreter;t;int;resTab;plus;V;B;b;E;xinO;lint;dot
⍝:: Execute local tests
⍝?: Execute local tests
⍝?:
⍝?: ]ExecuteLocalTest <path>CITA.json[5] -all [-workdir[=<location>]] [-empty] [-cleanup[=O|N]] | [-cleanup[=N]]] [-int=180U64...]
⍝Parse:               1L                 -all  -workdir[=]            -empty   -cleanup[∊]ON -int∊0123456789UC,
⍝??: Execute local tests
⍝??:
⍝??: <path>               location of CITA.json or CITA.json5 file
⍝??:
⍝??: -all                 tests against ALL local versions of dyalog (as defined in %CITA_ListOfInterpreters%) - otherwise tests currently active interpreter
⍝??: -int=ids             test against a subset of specified interpreters (commad-separated list ids according to ]APLVersions)
⍝??:
⍝??: -empty               delete all files from <location> before running tests
⍝??:
⍝??: -cleanup             files to delete after running tests:
⍝??: -cleanup=O           delete only Old files copied from <path> (keeps files resulting from tests)
⍝??: -cleanup=N           delete only New files created while running the tests (keeps files copied from <path>)
⍝??: -cleanup=ON          delete all files in <location> after running tests
⍝??:
⍝??: Hint: the result's header gives a first quick indication of the result: straight line indicates success. dashed line means failure!
⍝??
      res←¯1  ⍝ res=¯1 indicates no test were run!
      Log←''
      arg←##._Parse arg  ⍝ ensure its a parsed arg...
      fl←∊1 ⎕NPARTS(1 ''##._getArg 1 arg)  ⍝ fld=folder, fl=path to a CITA.json
      ('File or directory "',fl,'" not found')⎕SIGNAL(~⎕NEXISTS fl)/700
      fl,←(1=∊1 ⎕NINFO fl)/('\/'∊⍨⊢/fl)↓'/CITA.JSON'  ⍝ we also accept folders as arg and append the filespec automatically (since we're expecting one specific file anyway)
     
      fld←1⊃⎕NPARTS fl
      xinO←0(1⊃⎕NPARTS fl)##._getArg'workdir'arg
      xinO←∊1 ⎕NPARTS xinO
      xinO,←('/'≠⊢/xinO)/'/'
      :If ~⎕NEXISTS xinO
          (res Log)←702 'workdir does not exist'
          →0
      :EndIf
     
      :If xinO≢fld
          :If 0<≢list←⊃0(⎕NINFO⍠('Recurse' 1)('Wildcard' 1))xinO,'*'
              :If ~arg.Switch'empty'
                  (res Log)←702 'workdir is not an empty folder'
                  →0
              :Else
                  {}1 ⎕NDELETE⌽list  ⍝ transpose to be sure that we delete files before removing the subfolder containing them
              :EndIf
          :EndIf
      :EndIf
     
      int←0  ⍝ count of interpreter
      interpreters←,0  ⍝ default (signals to APLProcess to use current)
      resTab←1 1⍴' '  ⍝ tests x Interpreters - a summary table of test-results  - first row/col contains ids/names
      showedIO←0   ⍝ when we display test-counts instead of ids, give info about IO=1 (this var ensures we're doing it once only!)
      rcTest←¯1  ⍝ ¯1: no tests executed
      :If (~⎕NEXISTS fl)∨'cita.json'≢9↑⎕C∊1↓⎕NPARTS fl
          →0⊣(res Log)←700 'CITA.JSON[5] not found'
      :EndIf
      (rc specsObj lg)←_GetTestSpecs fl
      :If rc≠0
          (res Log)←701('Error processing specs in "',fl,'": ',⍕lg)
          →0
      :EndIf
      Log,←lg
      lint←''
      :If arg.Switch'all'
      :OrIf 0<≢lint←''arg.Switch'int'
          lg←APLVersions'-ucmd=0 -loglevel=2 -compact'
          Log,←⊆lg
          t←1⊃⎕NGET _FileWithListOfInterpreters
          interpreters←_FoldJson t
          interpreters←({6::1 ⋄ 'doc'≢⍵.id:0=≢⍵.disabled ⋄ 0}¨interpreters)/interpreters
          :If 0<≢lint
              interpreters←(interpreters.id∊','(≠⊆⊢)lint)/interpreters
          :EndIf
      :EndIf
     ⍝ (⎕lc[1]+1)⎕stop 1⊃⎕si
      :For interpreter :In interpreters
     
          xin∆←xinO,{0::⍵ ⋄ interpreter.id,'_'}''
     
     
          :If interpreter≡0
              t←{(⍕+/10 1×2↑2⊃'.'⎕VFI 2⊃⍵),('CU'[1+80=⎕DR' ']),(1+'64'≡¯2↑1⊃⍵)⊃'32' '64'}'.'⎕WG'aplversion'
          :Else
              t←interpreter.id
              →NextInt If~⎕NEXISTS interpreter.exe ⍝ make sure interpreter does exist...
              :If 2=interpreter.⎕NC'disabled'
              :AndIf 0<≢interpreter.disabled
                  →NextInt
              :EndIf
          :EndIf
          int+←1
          resTab←resTab,⊂''
          resTab[1;1+int]←⊂t
          cnt←0
          :If interpreters≢,0
              Log,←⊂'Interpreter ',interpreter.id
          :EndIf
          :For specs :In specsObj
              cnt+←1
              :If (cnt+1)>≢resTab ⋄ resTab←resTab⍪⊂'' ⋄ resTab[cnt+1;1]←⊂specs.id ⋄ :EndIf
              :If 2=specs.⎕NC'disabled'
              :AndIf 0<≢specs.disabled
                  resTab[cnt+1;int+1]←'~'
                  :Continue
              :EndIf
            ⍝   :If int=1 ⋄ resTab←resTab⍪⊂'' ⋄ resTab[cnt+1;1]←⊂specs.id ⋄ :EndIf
           ⍝ test if this apl qualifies...
              resTab[cnt+1;int+1]←'~'  ⍝ we assume it doesn't - this will be overridden later if it does
              :If 2=specs.⎕NC'dyalogversions'
                  :If 0<≢v←specs.dyalogversions
                      :If interpreter≡0
                          V←+/1 0.1×2↑2⊃'.'⎕VFI 2⊃'.'⎕WG'aplversion'  ⍝ current version
                      :Else
                          V←interpreter.version
                      :EndIf
     
                      plus←0  ⍝ did we see a +sign?
                      :If (⎕DR' ')=⎕DR v  ⍝ , separated list or a single version, possibly with "+
                          v←','(≠⊆⊢)v
                          (v plus dot)←↓⍉↑{(p d)←'+.'∊⍵ ⋄ (⊃2⊃⎕VFI ⍵~'+'),p,d}¨v
                      :Else
                          (v plus dot)←↓⍉↑{' '≠⍥⎕DR ⍵:⍵,0 0 ⋄ (p d)←'+.'∊⍵ ⋄ (⊃2⊃⎕VFI ⍵~'+'),p,d}¨,v
                      :EndIf
                      :If ~∨/(V∊v),(plus∧v<V),(dot∧V∊⍥⌊v)
                          :If interpreter≡0
                              Log,←⊂'Current interpreter (v=',(⍕V),') rejected by test which selected "',(⍕specs.dyalogversions),'"'
                          :Else
                              Log,←⊂'Interpreter ',interpreter.id,'(v=',(⍕V),') rejected by test which selected "',(⍕specs.dyalogversions),'"'
                          :EndIf
                          →EndForSpec
                      :EndIf
                  :EndIf
              :EndIf
              :If 2=specs.⎕NC'bits'
                  :If interpreter≡0
                      B←{⍵:64 ⋄ 32}∨/'64'⍷1⊃'.'⎕WG'APLVersion'
                  :Else
                      B←interpreter.bits
                  :EndIf
                  :If ~B∊specs.bits
                      :If interpreter≡0
                          Log,←⊂'Current interpreter (bits=',(⍕B),') rejected by test which selected "',(⍕specs.bits),'"'
                      :Else
                          Log,←⊂'Interpreter ',interpreter.id,' rejected by test which selected "',(⍕specs.bits),'"'
                      :EndIf
                      →EndForSpec
                  :EndIf
              :EndIf
     
              :If 2=specs.⎕NC'edition'
                  :If interpreter=0
                      E←(1+80=⎕DR' ')⊃'CU'
                  :Else
                      E←interpreter.edition
                  :EndIf
                  :If ~E∊specs.edition
                      :If interpreter≡0
                          Log,←⊂'Current interpreter (edition==',(⍕E),') rejected by test which selected "',(⍕specs.edition),'"'
                      :Else
                          Log,←⊂'Interpreter ',interpreter.id,' rejected by test which selected "',(⍕specs.edition),'"'
                      :EndIf
                      →EndForSpec
                  :EndIf
              :EndIf
              resTab[cnt+1;int+1]←' '
     
              log←''
              :If xin∆≢fld
                  xin←xin∆,(⍕specs.id),'/'
                  :Trap (~DEBUG)/0
                      ⎕MKDIR xin
                  :Else
                      xin←xin∆,(⍕cnt),'/'
                      log,←⊂'The jobid "',specs.id,'" caused an error when attempting to create a folder with that name.'
                      :Trap (~DEBUG)/0
                          ⎕MKDIR xin
                          log,←⊂'Solved that using counter (',(⍕cnt),') instead.'
                      :Else
                          log,←⊂'** Attempt to use counter (',(⍕cnt),') failed as well! Giving up.' ⋄ →EndStep
                      :EndTrap
                  :EndTrap
              :Else
                  xin←xin∆
              :EndIf
     
⍝ remember files we had before tests were executed...
              list←⊃0(⎕NINFO⍠('Recurse' 1)('Wildcard' 1))xin,'*'
              :If xin≢fld
                  :If 0≠xin _CopyFolder fld
                      (res log)←703 'Problem copying files into workdir-folder'
                      →EndStep
                  :EndIf
              :EndIf
     
              cfg←''
              :If 9=specs.⎕NC'config'
                  cfg←∊specs.config{⍵,'=',(⍕⍺⍎⍵),' '}¨specs.config.⎕NL ¯2
              :ElseIf 2=specs.⎕NC'config'
                  cfg←specs.config
              :EndIf
     
              R←0 ''
              :For step :In 'setup' 'test' 'teardown'
                  :If step≡'test'
                  :AndIf 0=specs.⎕NC step
                      R←4 'Missing entry for step "test"'
                  :Else
                      fl←specs⍎step
                      ⍝ ⎕← interpreter.id,' ',step
                      ⍝ (⎕lc[1]+1)⎕stop 1⊃⎕si
                      (rc jlog)←R←step _RunJob cfg specs interpreter
                      :If (⊂step)∊'setup' 'test'
                          rcTest←rc
                      :EndIf
                      :Select rc
                      :CaseList 0,(((⊂step)∊'setup' 'teardown')/4),(((⊂step)∊'test' 'teardown')/1) ⍝ we do nothing here, but may need to catch these cases...(and continue to the next step)
                      :Case 1
                          R←rc(step,' (using "',fl,'") failed')
                          :Leave
                      :Case 2
                          R←rc(step,' (using "',fl,'")  did not end properly (Timeout Error)')
                          :Leave
                      :Case 3
                          R←rc('No statusfile (CITA.',step,'.[ok|err]) found after ',step,' ended')
                          :Leave
                      :Case 4
                          R←rc('Invalid or non-existent file "',fl,'" for step "',step,'"')
                          :Leave
                      :EndSelect
                  :EndIf
              :EndFor
     
     EndStep:
              res←~(res∊0 ¯1)∧rcTest=0
              :If log≡'' ⋄ log←2⊃R ⋄ :EndIf
⍝              (⎕LC[1]+1)⎕STOP 1⊃⎕SI
              Log,←⊂(3⍴'·~*'[0 ¯1⍳rcTest]),' ',('#',(⍕cnt),' ',((~showedIO)/' (⎕IO=1) '),{0<≢⍵:'"',⍵,'"'}specs.id),({⍵=0:': success ···' ⋄ ⍵=¯1:': not executed ~~~' ⋄ ': FAILURE (return code = ',(⍕⍵),') ***'}rcTest)
              showedIO←showedIO∨''≡⍥⎕DR specs.id
              :If 0<≢log,jlog
                  log←(⊆log),⊆jlog
                  :If 1=≢log
                      Log,←⊂'    Message: "',log,'"'
                  :Else
                      Log,←⊂'     Log:'
                      Log,←⊂∊{(z/'     '),⍵,((z←0<≢⍵)∧~∨/(⎕UCS 13 10)∊∊⍵)/⎕UCS 13}¨log
                  :EndIf
              :EndIf
              Log,←⊂''
     
              resTab[cnt+1;int+1]←'+-tni?'[0 1⍳⊃,rcTest]
              list2←⊃0(⎕NINFO⍠('Recurse' 1)('Wildcard' 1))xin∆,'*'   ⍝ remember files we had before tests were executed...
              del←0⍴⊂''
     
              :Select v←arg.Switch'cleanup'
              :CaseList 'ON' 'NO'
                  :If fld≡xin∆
                      ⎕←'Use of modifier -cleanup=',v,' is not supported when -workdir was not given or the same as the source folder of CITA.json'
                  :Else
                      del←list2
                  :EndIf
              :Case 'N'
                  del←(~list2∊list)/list2
              :Case 1
                  :If fld≢xin∆
                      ⎕←'Use of modifier -cleanup without assignment of a value is not supported when -workdir is used '
                  :Else
                      del←(~list2∊list)/list2
                  :EndIf
              :Case 'O'
                  :If fld≡xin∆
                      ⎕←'Use of modifier -cleanup=',v,' is not supported when -workdir was not given or the same as the source folder of CITA.json'
                  :Else
                      del←list2
                  :EndIf
              :EndSelect
              :Trap (~DEBUG)/0  ⍝ :;trap 0 If ~DEBUG (AB!)
                  1 ⎕NDELETE⌽del   ⍝ we try to delete files and folders individually
              :Else
                  log←⊂'Trapped error while clearing folder "',xin∆,'":',nl,⎕JSON ⎕DMX
                  res←702
                  →EndStep
              :EndTrap
     EndForSpec:
          :EndFor
     NextInt:
      :EndFor
      :If interpreters≢,0    ⍝ if we run against multiple interpreters
      :AndIf rcTest≠¯1       ⍝ and tests were actually executed...
          Log,←↓⍕resTab
          Log,←'' 'Explanation of status-symbols:'
          Log,←⊂'+=success, -=failure, ~=disabled, t=timeout, n=not supported, ?=?'
      :EndIf
    ∇



    :section tools
    ∇ (R log)←step _RunJob cfg_specs_interpreter;cpu;dws;cmd;ext;proc;StatusFiles;ai3;log;specs;cfg;file;isDTest;Fullname;t;TestLog;log_file;exited
⍝ returncode: 0=ok
⍝             1=test failed
⍝             2=aborted because of Timeout
⍝             3=no status file found
⍝             4=invalid or non-existent file
⍝             5=environment not appropriate (i.e. 17.1 can not use LOAD= to deal with .aplf)
⍝ access global var "V" which has the APL-Version of the target-environment as a numeric value
⍝ access global var "E" which has the Edition of the target-environment (U|C)
     
      log←''
      dws←cmd←''  ⍝ Arguments for constructor of APLProcess
      R←0
      →(0=≢cfg_specs_interpreter)/EOF
      (cfg specs interpreter)←3↑⊆cfg_specs_interpreter
      file←specs{6::'' ⋄ ⍺⍎⍵}step
      →(0=≢file)/EOF
      isDTest←0   ⍝ do we have a ]DTest-Call?
     
      :If ~⎕NEXISTS xin,file
          R←4
          →EndJob
      :EndIf
     
    ⍝ step of Statusfiles to indicate failure [1] or success[2]
      StatusFiles←(⊂xin,'CITA.',⎕C step),¨'.err' '.ok'
      1 ⎕NDELETE¨StatusFiles  ⍝ make sure there are no old statusfiles around...
     
      ⍝...and explicitely set a log_file for each step (to be stored in workdir-folder):
      cfg,←' LOG_FILE="',(log_file←xin,'log_',step,'.dlf'),'" CITA_Log="',(∊2↑⎕NPARTS 1⊃StatusFiles),'"'
      cfg,←' APLCORENAME="',xin,'APLCORE_',step,'."'
      :If ⎕SE.SALTUtils.WIN   ⍝ if we're tunning under Windows
      ⍝ add those flags to better deal with possible exceptions...
          cfg,←'DYALOG_NOPOPUPS=1 PassExceptionsToOpSys=1'
      :EndIf
     
      cpu←⎕AI[3]
      Fullname←∊1 ⎕NPARTS xin,file
      :Select ext←⎕C 3⊃⎕NPARTS file
      :CaseList '.aplf' '.aplc' '.dyalog'
          TestLog←xin,'CITA_',(2⊃⎕NPARTS(-(ext≡''))↓Fullname),'.log'
          cmd←'CITATest="',Fullname,'" testlog="',TestLog,'"'
          dws←∊1 ⎕NPARTS ##.Home,'/client(testdriver)/RunCITA'
      :Case '.dws' ⋄ dws←Fullname
      :CaseList '' '.dyalogtest'
          R←4('.dyalogtest or folder-argument only valid for "test", not "',step,'"') ⋄ →(step≢'test')/EndJob
          :If ext≡'' ⋄ :AndIf 1≠1 ⎕NINFO Fullname ⋄ R←4 ⋄ →EndJob ⋄ :EndIf  ⍝ no extension, but does not refer to a folder
          TestLog←xin,'CITA_',(2⊃⎕NPARTS(-(ext≡''))↓Fullname),'.log'
          cmd←'CITATest="',Fullname,'"  testlog="',TestLog,'" ',specs{6::'' ⋄ 'dtestmods="',(⍺⍎⍵),'"'}'dtestmodifiers'
          dws←'"',∊1 ⎕NPARTS ##.Home,'/client(testdriver)/RunCITA"'
          isDTest←1
      :Else
          R←4('Did not recognize type of file "',file,'"') ⋄ →EndJob
      :EndSelect
      cmd,←' ',cfg
      ⍝ ⎕←'Executing APLProcess in dir ',xin,':',⎕ucs 13
      ⍝ ⎕← interpreter.exe dws,' 'cmd
      exited←¯1
      proc←⎕NEW ##.APLProcess(dws cmd(interpreter{0::0 ⋄ ⍺⍎⍵}'exe')'' ''xin)
      ai3←⎕AI[3]
      :While ~proc.IsRunning proc.Proc.Id ⋄ ai3←⎕AI[3] ⋄ :EndWhile   ⍝ wait until process has started
      :Repeat
          ⎕DL 1⌊specs.secondstimeout×1000  ⍝ delay one second by default, but allow smaller (if someone challenges our timeouts...)
      :Until (ai31←⎕AI[3])≥⌊ai3+specs.secondstimeout×1000
      :OrIf exited←proc.HasExited
     
      :If 0=⎕NC'exited'
      :OrIf exited∊0 ¯1   ⍝ TIMEOUT
          log←'Process did not complete within ',(1⍕0.001×⎕AI[3]-ai3),' seconds and was killed (SecondsTimeout=',(⍕specs.secondstimeout),((specs.secondstimeout=Timeout)/' default value'),')'
          {}proc.Kill
          R←2 ⋄ →EndJob
      :EndIf
      :If isDTest
         ⍝ how to determine success or failure? (On Windows we could use prod.GetExitCode, but that won't be general enough for CITA)
          :If ⎕NEXISTS TestLog  ⍝ logfile was created → tests failed!
              (⊂'')⎕NPUT 1⊃StatusFiles
              log←']DTest created a logfile ("',TestLog,'") indicating failed tests. Details in that file'
              R←1
          :Else               ⍝ absence of log indicates success
              (⊂'')⎕NPUT 2⊃StatusFiles
              R←0
          :EndIf
          →EndJob
      :EndIf
      :If ⎕NEXISTS 2⊃StatusFiles ⋄ R←0 ⋄ →EndJob ⋄ :EndIf
      :If ⎕NEXISTS 1⊃StatusFiles ⋄ log←'Test created logfile "',(1⊃StatusFiles),'" to indicate failed tests. More info might be found in it and in the APL Session-log "',log_file,'"' ⋄ R←1 ⋄ →EndJob ⋄ :EndIf
      R←3
     
     EndJob:
     EOF:
    ∇

    ∇ (rc rspec log)←_GetTestSpecs fl;cnt;specs;spec
      :Trap (~DEBUG)/rc←0
          log←''
          cnt←0
          rspec←⍬
     
          specs←_FoldJson 1⊃⎕NGET fl
          :If 2=specs.⎕NC'defaults'
              specs.(defaults{(⊂⍺ ⍵){(s t)←⍺ ⋄ 0=t.⎕NC ⍵:⍎'t.',⍵,'←s.',⍵}¨⍺.⎕NL-2}¨tests)    ⍝ Apply defaults to all tests
          :EndIf
     
          ⍝ and make sure we have something in Test (will be validated later)
          :For spec :In specs.tests
            ⍝ set defaults for optional entries Setup/Teardown
              spec←(⊂'setup'){0=⍵.⎕NC ⍺:⍵⊣⍵⍎⍺,'←''''' ⋄ ⍵}¨spec
              spec←(⊂'teardown'){0=⍵.⎕NC ⍺:⍵⊣⍵⍎⍺,'←''''' ⋄ ⍵}¨spec
              spec.secondstimeout←spec{6::⍵ ⋄ ⍺.secondstimeout}Timeout
              cnt+←1
              spec.id←spec{6::⍵ ⋄ ⍺⍎'id'}'#',⍕cnt
              rspec,←spec
          :EndFor
          :If rspec≡⍬ ⋄ rc←705 ⋄ →0 ⋄ :EndIf
      :Else
          rc←701 ⋄ log←⊂'Error reading "',fl,'":',nl,⎕JSON ⎕DMX
      :EndTrap
    ∇



    ∇ R←to _CopyFolder from;hf;n;t;h
    ⍝ can't use ⎕NCOPY because that would also copy hidden files/directories - which would really hurt in the case of ".git"
    ⍝ R is returncode. Values: 0=ok
    ⍝                          1=problems copying file
    ⍝                          2=problems creating a folder
      R←0
      from←∊1 ⎕NPARTS from ⍝ normalize it
      hf←⍬
      :For (n t h) :In ↓[1]↑0 1 6(⎕NINFO⍠('Wildcard' 1)('Recurse' 1))(from,'/*')   ⍝ get name, type & hidden-status
          hf,←(h∧t=1)/⊂n ⍝ collect step of hidden directories
          :If h=1 ⋄ :Continue ⋄ :EndIf
          :If 0<≢hf ⋄ :AndIf 1∊hf{⍺≡(≢⍺)↑⍵}¨⊂n ⋄ :Continue ⋄ :EndIf ⍝ file from a hidden folder
          :If 1=t  ⍝ directory
              :If from≡(≢from)↑n
                  :Trap (~DEBUG)/0
                      3 ⎕MKDIR to,(≢from)↓n ⋄ :Continue
                  :Else
                      →0⊣R←2
                  :EndTrap
              :Else
                  ⎕←'Paranoia justified!'
                  ∘∘∘
              :EndIf
          :Else
              :If 1≠(to,(≢from)↓n)⎕NCOPY n
                  →0⊣R←1
              :EndIf
          :EndIf
      :EndFor
      R←0
    ∇

      _FoldJson←{
          Apl←0 ⎕JSON⍠'Dialect' 'JSON5'⊢
          Json←1 ⎕JSON⍠'Compact' 0⊢
          FoldMembers←'^.*[^\\]":'⎕R{':',⍨Json ⎕C Apl ¯1↓⍵.Match}
          Apl FoldMembers Json Apl ⍵
      }


    ∇ file←_FileWithListOfInterpreters;docFld
      :Select platform←3↑1⊃'.'⎕WG'APLVersion'
      :Case 'Win'
          docFld←(2 ⎕NQ'.' 'GetEnvironment' 'USERPROFILE'),'/Documents/Dyalog APL Files'
      :Case 'Lin'
          docFld←'/home/',⎕AN,'/dyalog.files'
      :Case 'Mac'
          docFld←'/home/',⎕AN,'/dyalog.files'
      :EndSelect
      :If ~⎕NEXISTS docFld
          ⎕MKDIR docFld
      :EndIf
      file←∊1 ⎕NPARTS docFld,'/interpreters.json5'
    ∇
    :endsection



    :section UCMDs


    ∇ _InitUCMDs;fn;_quote;_findLine;nr;j;parse;maxH;h;hd;r
      ##.Home←##._getHomeDir
      ##.UCMD._List←'[',nl
      ##.UCMD._Help←0 3⍴''
      _quote←{'"',⍵,'"'}
      _findLine←{{(+/∧\⍵=' ')↓⍵}¨l↓¨(((l←2+≢⍵)↑¨⍺)≡¨⊂'⍝',⍵,':')/⍺}
      :For fn :In {('_'≠1⊃¨⍵)/⍵}##.API.⎕NL-3  ⍝ only for fns NOT starting with '_'
          nr←##.API.⎕NR fn
          j←'{'
          j,←'"Name":',_quote fn
          j,←',"Desc":',_quote∊nr _findLine':'
             ⍝ Parse: we also support parseU/parseA to allow for different syntax when API-Fn is used via UCMD or API-Calls.
          :If 0=≢parse←∊nr _findLine'Parse'
              parse←∊nr _findLine'ParseU'
          :EndIf
          j,←',"Parse":',_quote parse
          j,←',"Group":"CITA"'
          j,←'}'
          ##.UCMD._List,←j,','
          maxH←⌈/0,∊('⍝\s*(\?+):'⎕S{¯1↑⍵.Lengths})nr
          :For h :In ⍳maxH
              ##.UCMD._Help⍪←(⊂fn),(h-1),[1.5]nr _findLine h⍴'?'
          :EndFor
          :Select 1 2⊃AT←##.API.⎕AT fn
          :Case 0 ⍝ niladic or not a fn
              hd←fn
          :Case 1 ⍝ monadic
              hd←fn,' rarg'
          :CaseList ¯2 2
              hd←'larg ',fn,' rarg'
          :EndSelect
          :Select 1⊃1⊃##.API.⎕AT fn
          :Case 1
              hd←'R←',hd
          :Case ¯1
              hd←'{R}←',hd
          :EndSelect
          r←'←'∊hd
          hd←(⊂hd),⊂':if 2=⎕nc''larg''⋄',(r/'R←'),'larg _getAPI ''',fn,''' rarg'
          hd,←⊂':else⋄',(r/'R←'),'_getAPI ''',fn,''' rarg'
          hd,←⊂':endif'
          :Trap 0 If DEBUG
              2 ##.⎕FIX hd
          :Else
          ⍝ return error building API fns...
              ∘∘∘
          :EndTrap
      :EndFor
      ##.UCMD.(⊃⌽_List)←']'
    ∇

    ∇ new←{opt}_FilterVersions dsl;inst;l3;cmd;disable;z;range;objs
⍝ Process ","-separated filters in dsl to build list of selected interpreters
⍝ This implements a DSL for selection of Dyalog interpreters:
⍝ [mode][[version[s]]|/][edition][bits]
⍝ if version(s) is elided, a / must be given to indicate missing first element. (This allows us to recognize "/32" as a bitness-selector)
⍝ mode is optional, default is + (select). Alternative values: ~ (=un-select, disable)
⍝ [version] is any number, optionally with decimals and selects a version-number. Using syntax from-to you may also specify a range of versions.
⍝ [edition]∊uUcC or _: Unicode, Class or "_" for both
⍝ [bits] is 32 or 64 or can be elided to select both
⍝ each of the three elements can be elided, but at least one must be given for a sensible selection obviously...
⍝
⍝ optional left arg can be used to control result:
⍝ x - return vtv with path(s) to exe
⍝ i =    -II-         id(s)
⍝ o =    -II-         objects (containing fields as exe, id etc. - from the file ]APLVersions uses )
⍝ Selections will be applied in the sequence they appear. Each operation adds to new - starting with an empty list obviously.
          objs←⎕JSON 1⊃⎕NGET _FileWithListOfInterpreters
          objs←(objs.id≢¨⊂'doc')/objs
          list←objs.id
      l3←('(\d\d[\.?\d]?)([ |c|u])(\d{2})'⎕S'\1 \2 \3'⍠1)list
      ⍝ convert list into [;1]=id, [;2]=version, [;3]=bits, [;4]=edition
      l3←list,↑{({⍬⍴(2⊃⎕VFI 2↑⍵)+(2<≢⍵)×0.1×2⊃⎕VFI ¯1↑⍵}¨⍵[1 3]),⎕C 2⊃⍵}¨{' '(≠⊆⊢)⍵}¨l3
      new←⍬   ⍝ start with an empty list
      :For cmd :In ','(≠⊆⊢),dsl   ⍝ look at one instruction after the next
          disable←'~'=⊃cmd ⋄ cmd←(∨/'+~'=⊃cmd)↓cmd
          :If cmd≡⍥⎕C'all'
              z←(≢l3)⍴~disable
          :Else
              :If '/'≠⊃cmd
                  range←0 ¯1 99 0 0 ⍝ range[1]: yes, "-" was used, [2] is start and [3] is end of range, range [4 5]: was a '.' used in the version-spec 2&3
                  :If ∧/(2↑cmd)∊⎕D
                      z←∧\((≢cmd)↑1 1)∧cmd∊⎕D,'.'  ⍝ just get the leading digits
                      range[2]←⍬⍴2⊃⎕VFI z/cmd
                      cmd←(~z)/cmd
                      :If 0<≢cmd
                      :AndIf range[4]←∨/z←∧\cmd∊'.',⎕D
                          range[2]+←{⍵<1:⍵ ⋄ ⍵×0.1}⍬⍴2⊃⎕VFI(('.'≠⊃cmd)⍴'.'),z/cmd
                          cmd←(~z)/cmd
                      :EndIf
                  :EndIf
                  range[1]←'-'=⊃cmd
                  cmd←range[1]↓cmd
                  :If 0<≢cmd
                  :AndIf ∨/z←∧\((≢cmd)↑1 1)∧cmd∊⎕D,'.'  ⍝ just get the leading digits
                      range[3]←⍬⍴(2⊃⎕VFI z/cmd)+⍬⍴0.1×{2⊃⎕VFI'.'~⍨(∧\⍵∊⎕D,'.')/⍵}'0',⍨(~z)/cmd
                      cmd←(~z)/cmd
                      :If 0<≢cmd
                      :AndIf range[5]←∨/z←∧\cmd∊'.',⎕D
                          range[3]+←{⍵<1:⍵ ⋄ ⍵×0.1}2⊃⎕VFI z/cmd
                          cmd←(~z)/cmd
                      :EndIf
                  :EndIf
                  range[2]←{⍵[2]:⍵[1] ⋄ ⌊⍵[1]}range[2 4]
                  range[3]←{⍵[2]:⍵[1] ⋄ 0.999+⌊⍵[1]}range[3 5]
                  :If range[1]  ⍝ if range was specified
                      z←l3[;2]{(⍵[1]≤⍺)∧(⍵[2]≥⍺)∨⍵[2]=¯1}1↓range
                  :ElseIf range[4] ⍝ if . was used in 2
                      z←(l3[;2])=range[2]  ⍝ version must match exactly
                  :ElseIf range[2]>0
                      z←(⌊l3[;2])=range[2]
                  :Else
                      ⎕EX'z'
                  :EndIf
              :Else
                  cmd←1↓cmd
              :EndIf
              :If ∨/'_uc'∊⎕C⊃cmd
                  :If (⎕C⊃cmd)∊'cu'
                      z←'z'{6::⍵ ⋄ ⍵∧⍎⍺}l3[;4]=⎕C⊃cmd
                      z←'z'{6::⍵ ⋄ ⍵^⍎⍺}(≢l3)⍴1  ⍝ select all
                  :EndIf
                  cmd←1↓cmd
              :EndIf
              :If (⊂cmd)∊'32' '64'
                  z←'z'{6::⍵ ⋄ ⍵∧⍎⍺}l3[;3]∊2⊃⎕VFI cmd
              :EndIf
          :EndIf
          :If 0=⎕NC'z'
              :Continue
          :EndIf ⍝ nothing has been selected
          :If disable
              new←new~z/l3[;1]
          :Else
              new,←z/l3[;1]
          :EndIf
      :EndFor
      :If 2=⎕NC'opt'
          :Select ⎕C opt
          :Case 'x'
              new←z/objs.exe
          :Case 'i'
              new←z/objs.id
          :Case 'o'
              new←z/objs
          :EndSelect
      :EndIf
     
    ∇
    :endsection


:endnamespace

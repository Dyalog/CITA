stage ("aix&&%CITA_VERSION%&&%VERSION%") {
  node ("aix&&%CITA_VERSION%&&%VERSION%") {
    [%BITS%].each { BITS ->
      [%EDITIONS%].each { EDITION ->
        [%EXTRAS%].each { P ->
          catchError(buildResult: "UNSTABLE", stageResult: "FAILURE") {
            echo "NODE_NAME = ${env.NODE_NAME}"            
            path = "/opt/mdyalog/%VERSION%/${BITS}/${EDITION}/${P}/mapl"
            exists = fileExists(path)          
            if (!exists) {
              error "Found no interpreter for ${env.NODE_NAME}. Labels: ${env.NODE_LABELS}"
            }
            cmdlinePre = '%CMDLINEPRE%'
            if (cmdlinePre != "")
            {
              sh "$cmdlinePre"
            }
            if ("$EDITION" == "classic") {
              sh 'echo ")off" | APLT1=utf8 APLT2=utf8 APLK0=utf8'
            }
            E = EDITION.take(1)
            testPath="%xinO%aix_%VERSION%_${P}_${E}${BITS}/"
            cmdline = "%CMDLINE% citaDEVT=${citaDEVT} USERCONFIGFILE=${testPath}cita.dcfg CITA_Log=${testPath}CITA.log LOG_FILE=${testPath}CITA_Session.dlf"
            echo "Launching $path $cmdline "
            // sh "$path $cmdline" 
            rcj =  sh(script: "$path $cmdline" , returnStatus: true)
            echo "rcj=$rcj"           
            if (exists) {
              echo "Test succeeded"
              rc = (rc < 1)?0:1
            } else {
              echo "Test did not end with status file ${testPath}CITA.log.ok"
              rc = 1
            }
          }
        }
      }
    }
    sh "exit $rc"
  }
}